---
layout: post
author: "杨小定定"
title:  "DB2 日志"
description: "在本篇里，我们来看看DB2日志的相关一些知识。"
date:   2018-03-06
categories: technology
---

在本篇里，我们来看看DB2日志的相关一些知识。

主要从以下几个方面来谈谈：

- DB2日志文件
- DB2日志类型
  - 循环日志
  - 归档日志
- 日志文件的规划
- 日志相关参数配置
- 相关建议

## DB2 日志简介

我们知道数据库有备份，关于备份，可以简单的理解为*复制*，其实备份就是给特定时刻的数据库做一次复制。

那么恢复的话，也可以看做是*复制*，就是将数据恢复到我们备份的那个时刻。

现在假设我们昨天晚上做的备份，今天中午数据库出了故障，需要恢复。

我们就先将数据库恢复到昨天晚上的那个时刻，但是备份之后到今天中午的这段时间的操作怎么办呢？

这就需要用到数据库日志。

一旦事务提交，我们对数据库的修改（insert、update和delete等）都会记录到数据库日志中。

所以我们可以通过数据库日志将备份后和故障前的操作全部都重做（redo）一遍。（前提是数据库日志文件没有损坏）

以上就是数据库**前滚恢复的原理**。

## DB2 日志文件

日志是记录到文件中的。

采用的是*提前写日志存档模式*，是指：当发出删除、插入或更新数据库中某一数据的SQL调用时，所做的数据变更首先要写到日志文件中，当发出一条SQL COMMIT命令时，DB2需要把数据写入表中，而在DB2接收到COMMIT命令之后且在数据开始写入到表中之前，DB2要保证已经把为了重做（redo）所需要的日志文件都写入磁盘中。

这样就保证了日志可以用于恢复任何已经COMMIT的事务。

下图示例表示了这一过程：

```
  DB2 Memory(in RAM)
+-----------------------------------------------------------------------------------------------+
|  Package cache                                                                                |
| +----------------------------------+                                                          |
| | Update mytable set name='ZZZ'    |                   Log Buffer                             |
| |     where Name in ('John','Raul')|                  +-------------------------------------+ |
| | Delete mytable                   |                  | Update Old value John/new value ZZZ | |
| |     where Name='Peter'           |  Writing to      | Update Old value Raul/new value ZZZ | |
| | Commit                           |  the Log Buffer  | Delete Old value=Peter              | |
| | Delete mytable                   +----------------->| Commit                              | |
| |     where Name='Mary'            |                  | Delete Old value=Mary               | |
| +----------------------------------+                  +------------------+------------------+ |
|  Bufferpool                                                              |                    |
| +------------------------------+           When the Log Buffer is full,  |                    |
| |  Data Page 1   Data Page 2   |           or a commit is issued, the    |                    |
| | +-----------+ +------------+ |           logs are written to the log   |                    |
| | | Name=John | | Name=Peter | |           files.                        |                    |
| | | Name=Mary | | Name=Rual  | |                                         |                    |
| | +-----------+ +------------+ |                                         |                    |
| +-----+------------------------+                                         |                    |
+-------|------------------------------------------------------------------|--------------------+
        | Externalizing to the database                                    |
        | (in this example, it has not happend yet)                        |
        v                                                                  v
+-----------------------------------------------+   +-------------------------------------------+
| +---------+                                   |   |      +------------+                       |
| |         +---------------------------------+ |   | +----+ Log File 1 +-------------------+   |
| | +-----------+ +------------+ +----------+ | |   | |      +------------+                 |   |
| | | Name=John | | Name=Peter | | Name=WWW | | |   | | +----+ Log File 2 +-------------------+ |
| | | Name=Mary | | Name=Raul  | | Name=YYY | | |   | | | Update Old value John/new value ZZZ | |
| | +-----------+ +------------+ +----------+ | |   | | | Update Old value Raul/new value ZZZ | |
| +-------------------------------------------+ |   | | | Delete Old value=Peter              | |
+-----------------------------------------------+   | +-| Commit                              | |
        Disk for the database                       |   | Delete Old value=Mary               | |
                                                    |   +-------------------------------------+ |
                                                    +-------------------------------------------+
                                                                   Disk for logs
```

日志中至记录DML操作（insert、update和delete），会同时记录该操作的redo和undo操作。

undo是保证能够执行回滚（rollback）操作；而redo是保证数据库可执行前滚（roll forward）操作。

日志内容还有一个LSN，全称为Log Sequence Number，日志顺序号。它是日志文件中日志记录的唯一标识，在数据库中LSN永远不会重复，主要用来精准定位日志记录。

## DB2 日志类型

数据库中有两类日志：

- 循环日志（circular logging）
- 归档日志（archival logging）

其中，循环日志是DB2默认的日志记录模式。

### 循环日志

> 循环日志：
> 将`logarchmeth1`和`logarchmeth2`数据库配置参数设置为`OFF`。

在循环日志记录模式下，只要这个日志文件中包含的数据已经全部提交且已经写到磁盘上，这个日志文件就可以被重用。

循环日志使用两种日志文件：

- 主日志文件（primary log files）
- 辅日志文件（second log files）

主日志文件是预先分配的，也就是在数据库启动过程中创建，是数据库启动的一部分；而辅日志文件仅在需要时才分配（但分配后不会主动回收，除非重启数据库）。

如果数据库需要下一个日志文件，并且主日志文件已经用完且不能被重用，那么将分配辅日志文件，直至主日志文件变得可供重用或者分配的辅日志文件的数量达到限制为止。

> Ps.主日志文件和辅日志文件的数目由数据库参数`LOGPRIMARY`和`LOGSECOND`来决定。

因为会重用日志文件，我们可以想象到，循环日志记录数据库，仅能恢复到曾经做过备份的点。对数据库进行恢复时，备份点之后对数据库做的所有工作都将丢失。

所以，循环日志方式最合适用于那些只供查询的数据库或开发测试类型的数据库，重要的生产数据库不建议使用。

### 归档日志

> 归档日志：
> 可使用`logarchmeth1`和`logarchmeth2`数据库配置参数来指定已归档日志的存储位置。
> 可使用`logarchmeth1`参数对`logpath`配置参数设置的活动日志路径中的日志文件归档。
> 可使用`logarchmeth2`参数将活动日志路径中的日志文件的其他副本归档至另一位置。
> 如果未配置镜像日志记录，那么将从`logarchmeth1`参数使用的同一日志路径中获取其他副本。
> 如果配置了镜像日志记录（通过`mirrorlogpath`配置参数），那么`logarchmeth2`配置参数将改为对镜像日志路径中的日志文件归档，这可以在前滚恢复期间提高弹性。
> `newlogpath`参数影响活动日志的存储位置。

在循环日志记录模式下，已提交且被写到磁盘上的日志文件将会被重用；

而在归档日志记录模式下，这些日志文件将得到保留。

当使用归档日志记录模式时，数据库会经常归档（保留）日志。

举例说明：

假设有4个主日志文件，DB2将依次使用它们 Log #1、Log #2、Log #3、Log #4；
当Log #4都满了，需要新增一个日志时，会先判断：如果Log #1的所有事物已被提交且已写到磁盘上，则归档Log #1。然后再新增Log #5。
Log #6等，依次类推。

也就是在使用完一个日志文件后，会创建并使用新的日志文件，并同时将最早的已经使用完成的日志文件归档。（即不会重用原有的日志文件）

包含以下两点中任意一条的，就叫做**活动（active）日志文件**:

- 包含尚未提交或回滚的事务信息
- 包含已经提交但是更改尚未写到磁盘上的事务信息

如上示例中，当有Log #1、Log #2、Log #3、Log #4、Log#5、Log #6这六个日志文件时，其中Log #4、Log #5、Log #6就是活动日志；

Log #3，此时还在ACTIVE日志子目录中，包含已经提交的事务且已经写到磁盘上，称之为**在线归档**；

Log #1、Log #2，文件来自ACTIVE日志子目录 ，此时可能已经移动到了其它目录或其它介质上（手动或DB2自动），称之为**离线归档**；

此外还有**镜像日志（mirrorlog）**，是在数据库级别配置的，活动日志的副本，有助于防止数据库无意中删除活动日志以及硬件故障导致的数据损坏。

通过上述示例，我们看到，在新增Log #5时，还需要先归档Log #1，而假设这时Log #1上还有未提交的事务（不能归档Log #1），则不能新增Log #5，此时报日志满错误。

这是因为归档日志下，其可用的活动日志大小依然受到主日志与辅日志大小之和的限制（上述示例为4），所以日志满的场景与循环日志下是完全一样的。

## 日志文件的规划

根据您的需要以及配置参数设置的不同，日志文件的空间需求也将有所变化。

日志控制文件需要 56 KB 的空间。至少还需要足够的空间以进行活动日志配置，可进行如下计算

```
(logprimary + logsecond) × (logfilsiz + 2 ) × 4096
```

其中：

- `logprimary`是数据库配置文件中定义的主数据库日志文件数
- `logsecond`是数据库配置文件中定义的辅助数据库日志文件数；在此计算中，不能将`logsecond`设置为 -1（如果`logsecond`设置为 -1，那么表明您正在请求获取不受限的活动日志空间）
- `logfilsiz`是数据库配置文件中定义的每个日志文件中的页数
- `2`是每个日志文件所需的标题页的数目
- `4096`是一页中的字节数

此计算针对为日志文件规划所需磁盘空间提供了一般准则。但是，必须确保为潜在的日志归档故障提供了足够的磁盘空间（如果所选日志归档方法失败）。这可能促使保留日志文件，直到这些日志文件已成功归档。因此，根据事务填充日志文件的速度以及您注意到日志归档故障所用的时间，大量日志文件可能会保留并且占用大量可用的磁盘空间。出于性能原因，DB2 进程可能会将一些额外的已归档日志文件保留在日志路径中。因此，您在日志路径中看到的日志文件可能会比期望的更多。

**前滚恢复**

如果已对数据库启用前滚恢复，那么可考虑特殊日志空间需求：

- 如果`logarchmeth1`配置参数设置为`LOGRETAIN`，那么将在日志路径目录中归档日志文件。除非将日志文件移至另一个位置，否则，联机磁盘空间最终将会填满。
- 如果`logarchmeth1`配置参数设置为`USEREXIT`、`DISK`或`VENDOR`，那么用户出口程序会将已归档的日志文件移至另一个位置。要允许下列情况，附加的日志空间仍是必需的：
  - 等待用户出口程序移动的联机归档日志文件
  - 格式化新的日志文件，以供将来使用
- 如果对归档日志文件启用压缩，那么可减少存储这些文件的成本。
  - 例如，如果`logarchmeth1`配置参数设置为`DISK`、`TSM`或`VENDOR`，并且您将`logarchcompr1`配置参数设置为`ON`，那么系统会压缩归档日志文件并且可减少存储这些文件的成本。如果以动态方式启用压缩，那么不会压缩已存储的现有归档日志文件。启用压缩后，压缩从当前活动日志文件开始。

**循环日志记录**

如果已对数据库启用了循环日志记录，那么此公式的结果是分配所有空间以进行日志记录；即，不会分配更多空间，并且对于任何日志文件，您都不会接收到“磁盘空间不足”错误。

**无限日志记录**

如果已对数据库启用无限日志记录功能（即，将`logsecond`配置参数设置为`-1`），那么必须将`logarchmeth1`配置参数设置为除`OFF`或`logretain`以外的值才能启用归档日志记录功能。数据库管理器将在日志路径中至少保留`logprimary`配置参数所指定数目的活动日志文件，因此，不得对以上公式中`logsecond`配置参数使用值`-1`。确保提供额外磁盘空间以允许归档日志文件导致的延迟。

**镜像日志路径**

如果正在镜像日志路径，那么必须将估计的日志文件空间需求增大一倍。

**当前已落实**

如果查询返回数据的当前已落实值，并且`cur_commit`配置参数未设置为`DISABLED`，那么需要更多的日志空间才能记录事务运行期间对数据行进行的第一次更新。根据工作负载大小的不同，所使用的日志空间总量可能会有很大的变化。此方案影响任何工作负载所需的日志 I/O、所需的活动日志空间量以及所需的日志归档空间量。

## 日志相关参数配置

下表列出与日志相关的一些参数配置：

| 参数 | 用途 | 说明 |
|:--- |:--- |:--- |
| `LOGPRIMARY` | 指定将创建的大小为`logfilsiz`的主日志数 | 主日志文件，无论是空的还是满的，都需要相同的磁盘空间容量。对活动日志空间的总日志文件大小限制为 256 GB。 |
| `LOGSECOND` | 指定创建并用于恢复（如果需要）的辅助日志文件的数目 | 如果主日志文件已满，可按需要一次分配一个辅助日志文件（大小为`logfilsiz`），最多可分配由此参数指定的最大数目。如果此参数设置为 -1，那么将数据库配置为无限活动日志空间。 |
| `LOGFILSIZ` | 以 4 KB 的页数指定每个配置日志的大小 | 对可配置的每个日志流的总活动日志空间有 1024 GB 的逻辑限制。此限制源自每个日志文件的上限（即 4 KB）以及最大主日志文件数与最大辅助日志文件数之和（即 256）。日志文件的大小对性能有直接的影响。从一个日志切换至另一个日志需要付出性能代价。因此，从纯性能角度来说，日志文件大小越大越好。此参数还指示要归档的日志文件大小。这种情况下，日志文件大小越大并不一定越好，因为较大的日志文件大小增加了故障或导致日志装入方案中的延迟的发生机率。当考虑活动日志空间时，最好有较多的较小日志文件。 |
| `LOGBUFSZ` | 指定在将日志记录写至磁盘之前用作这些记录的缓冲区的内存量 | 增加日志缓冲区的大小可使与日志记录关联的输入/输出 (I/O) 活动更有效，因为将日志记录写到磁盘中的频率更低，而每次写入的记录却更多。但是，如果日志缓冲区大小值较大，执行恢复所需的时间就会较长。此外，您也能够使用较高的`logbufsz`设置来减少从日志磁盘的读取次数。 |
| `MAX_LOG` | 指示一个事务可以消耗的主日志空间的百分比。该值是为`logprimary`配置参数指定的值的百分比。 | 如果该值设置为 0，那么对一个事务可以消耗的总的主日志空间的百分比没有限制。如果应用程序违反了`max_log`配置，那么将强制该应用程序与数据库断开连接并且事务将回滚。 |
| `NUM_LOG_SPAN` | 指示一个活动事务可以跨越的活动日志文件数 | 如果该值设置为 0，那么对单个事务可以跨越的日志文件数没有限制。如果应用程序违反了 num_log_span 设置，那么将强制该应用程序与数据库断开连接。 |
| `NEWLOGPATH` | 数据库日志最初创建于下列目录：<br/> `db_path/instance_name/dbname/NODE0000/LOGSTREAM0000`。<br/> 通过将此配置参数的值更改为指向另一目录或另一设备，<br/> 可以更改放置活动日志文件（将来会放置以后的归档日志）的位置 | 如果数据库被配置为进行前滚恢复，那么不要将当前存储在数据库日志路径目录中的归档日志移至新位置。 |
| `MINCOMMIT` | 对组的落实次数 | 此参数允许您延迟将日志记录写入磁盘，直到执行了最小数目的落实为止。 此延迟可有助于减少与写入日志记录关联的数据库管理器开销，这样如果您有多个应用程序对数据库运行，且在很短的时间内该应用程序请求了许多落实，那么可改进性能。仅当此参数的值大于 1，且多个应用程序大约同时尝试落实其事务时，才会对落实进行这种分组。落实组合生效时，保持应用程序落实请求，直到经过 1 秒钟或落实请求数等于此参数的值为止。 | 
| `NUMARCHRETRY` | 出错时的归档重试次数 | 指定在日志文件归档到`failarchpath`配置参数指定的路径之前，使用配置的日志归档方法归档日志文件的尝试次数。如果设置了`failarchpath`配置参数，那么只能使用该参数。缺省值为 5。 |
| `ARCHRETRYDELAY` | 归档重试延迟 | 指定在上一次尝试失败之后，归档日志文件尝试之间等待的时间量（以秒计）。缺省值为 20。 |
| `LOGARCHCOMPR1`<br/>`LOGARCHCOMPR2` | 主日志归档压缩和辅助日志归档压缩 | 在某些情况下，这些参数控制数据库管理器是否压缩归档日志文件。如果对日志归档文件进行压缩，那么可以减少与存储这些文件相关联的开销。可用值为`OFF`-此值指定不压缩日志归档文件。缺省值为 OFF; `ON`-此值指定压缩日志归档文件。如果以动态方式设置，那么不会对已归档的日志文件进行压缩。 |
| `MIRRORLOGPATH` | 镜像日志路径 | 要防止主日志路径上的日志发生磁盘故障或被无意中删除的情况，可以指定在辅助（镜像）路径上维护完全相同的一组日志。要执行此操作，将此配置参数的值更改为指向另一目录。如果数据库被配置为进行前滚恢复，那么不要将当前存储在镜像日志路径目录中的归档日志移至新位置。要关闭此配置参数，将它的值设置为`DEFAULT`。 |
| `LOGARCHMETH1`<br/> `LOGARCHMETH2` | 日志归档方法 1、日志归档方法 2 | *详情见下附注一* |

*附注一*：  
这些参数使数据库管理器将日志文件归档至活动日志路径之外的位置。如果同时指定这两个参数，那么由`logpath`配置参数设置的活动日志路径中的每个日志文件均会进行两次归档。这意味着将在两个不同目标位置具有该日志路径中的已归档日志文件的两个相同副本。如果通过使用`mirrorlogpath`配置参数指定了镜像日志记录，那么`logarchmeth2`配置参数将归档镜像日志路径中的日志文件，而不是归档活动日志路径中日志文件的其他副本。这意味着将在两个不同目标位置归档日志文件的两个不同副本：一个副本来自活动日志路径，另一个副本来自镜像日志路径。

这些参数的有效值如下所示：

- `OFF`
  - 此值指定不使用日志归档方法。如果将`logarchmeth1`和`logarchmeth2`配置参数都设置为`OFF`，那么认为数据库正在使用循环日志记录，且不可前滚恢复。缺省值为`OFF`。
- `LOGRETAIN`
  - 指定活动日志文件文件保留并成为联机归档日志文件以用于前滚恢复。
- `USEREXIT`
  - 指定执行日志保留日志记录并应使用用户出口程序来归档和检索这些日志文件。日志文件是在变满时归档的。前滚实用程序必须使用日志文件来复原数据库时会检索这些日志文件。
- `DISK`
  - 此值后必须紧跟冒号 (`:`)，然后是现有标准路径名，日志文件将在其中归档。例如，如果将`logarchmeth1`配置参数设置为`DISK:/u/dbuser/archived_logs`，那么归档日志文件将放入`/u/dbuser/archived_logs/INSTANCE_NAME/DBNAME/NODExxxx/LOGSTREAMxxxx/Cxxxxxxx`目录。
- `TSM`
  - 如果指定不带有任何附加配置参数，那么此值指示应该使用缺省管理类，将日志文件归档在本地 Tivoli® Storage Manager (TSM) 服务器上。如果此值后紧跟冒号（`:`）和 TSM 管理类，那么使用指定的管理类来归档日志文件。
- `VENDOR`
  - 指定将使用供应商库来归档日志文件。此值后必须紧跟冒号（`:`）和库的名称。库中提供的 API 必须使用备份并复原供应商产品的 API。

## 相关建议

关于日志的设置，有如下相关建议：

- 尽量使用归档日志模式
  因为只有这个设置才能与数据库备份配合，达到将数据库恢复到任何时间点的目标。
- 日志大小，主、辅日志数量的设置考虑
  一般情况下，考虑设置主日志的数量需要能够满足日常使用需求，并预留一定的富余空间即可。设置辅日志数量的一般考虑因素是在特殊情况下能提供足够的缓冲，从而在负载出现波动的情况下，不至于将数据库日志空间用尽。
  但在对响应时间有非常高要求的交易型数据库中，建议将主日志的数量增大。因为当主日志的空间用尽而需要创建新的日志文件时，数据库会出现数据写被短暂挂起，直至新的日志文件创建完成，数据库才能继续写入数据。
- 日志缓冲的考虑
  默认设置256，一般已经足够，除非有特殊需求，否则无需调整。
- 提高写日志性能
  评估日志写性能的指标可以按照以下方法获得

```bash
$ db2 get snapshot for db on [DBNAME] | more

                      Database Snapshot
......
Log write time (sec.ns)                           = 25512.063380216
Number write log IOs                             = 26347156
......
```

日志写的平均时间 = Log write time/Number write log IOs = 25512.063380216/26347156 = 0.98ms

一般情况下，小于5ms的值应该属于正常范围。
